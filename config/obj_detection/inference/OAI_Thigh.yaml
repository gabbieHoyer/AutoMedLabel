model: YOLO8/yolov8n.pt
model_type: YOLO
data_yaml: thigh_data.yaml
imgsz: [1024, 512]  # technically this is variable :/ three different variations exist in thigh oai dataset
epochs: 100 #1 #300
batch: 16
rect: true

# best_weights: runs/detect/train/weights/best.pt
# yolo_weights: work_dir/model_weights/finetuned/thighYOLO/temp.pt
# sam_weights: work_dir/model_weights/finetuned/muscleSAM/20240530-0438_finetuned_model_best.pth

base_model: "work_dir/model_weights/SAM/sam_vit_b_01ec64.pth"

models:
  obj_det: 
    model_path: 'work_dir/model_weights/finetuned/thighYOLO/best.pt'
    model_weights: 'thighYOLO8'
    model_type: YOLO
  segmentation:
    model_path: 'work_dir/model_weights/finetuned/muscleSAM/20240530-0438_finetuned_model_best.pth'
    model_weights: 'muscleSAM'
    model_type: vit_b
    
    # trainable:
    #   prompt_encoder: false
    #   image_encoder: false
    #   mask_decoder: true

dicom_data: standardized_data/challenging_cases/dicom_image_sample/00m/9015402
# nifti_data: standardized_data/challenging_cases/nifti_image_sample/00m/OAI_9015402.nii.gz
nifti_data: standardized_data/full_thigh_nifti/train/images/OAI_9437407.nii.gz  # should work; it ran through train looools - use as backup

preprocessing_cfg:
  image_size: 1024  # should probably just be 1024
  voxel_num_thre2d: 100
  voxel_num_thre3d: 200
  remove_label_ids: []  # No labels to remove in this configuration 
  target_label_id: null  # No specific label targeted for instance segmentation
  instance_bbox: True
  
  crop_non_zero_slices_flag: False
  bbox_shift: 20
  infer_method: '3D_stepwise' # Options: '3D_stepwise' or '3D_one_step'

device: cuda:0


base_output_dir: standardized_data/thigh_inference

# --- OUTPUT (OVERRIDE DEFAULT): Location to output labels .txt files
inference_dir: annotations

# --- OUTPUT (OVERRIDE DEFAULT): Location to output (gt, prediction) .npz files
inference_dir: preds

output_configuration:
  save_path: work_dir/prompting/${experiment.name}/Prompt_Summaries
  logging_level: DEBUG 


# data: standardized_data/thigh_npy3_instance/test/images/OAI_9437407-003.npy
# data: standardized_data/full_thigh_npy/test/images


# source: # (str, optional) source directory for images or videos
# vid_stride: 1 # (int) video frame-rate stride
# stream_buffer: False # (bool) buffer all streaming frames (True) or return the most recent frame (False)
# visualize: False # (bool) visualize model features
# augment: False # (bool) apply image augmentation to prediction sources
# agnostic_nms: False # (bool) class-agnostic NMS
# classes: # (int | list[int], optional) filter results by class, i.e. classes=0, or classes=[0,2,3]
# retina_masks: False # (bool) use high-resolution segmentation masks
# embed: # (list[int], optional) return feature vectors/embeddings from given layers


# see if prediction can take place on folder in images??





# resources for this development:

# https://docs.ultralytics.com/usage/engine/#other-engine-components
# https://docs.ultralytics.com/usage/engine/

# https://www.reddit.com/r/pytorch/comments/tl1a7f/yolo_annotated_dataset_to_custom_dataloader/


# Yes, it's definitely possible to define custom DataLoader and Augmentation pipelines in DetectionTrainer! ðŸš€ To do so, you'd primarily override the get_dataloader() method in a subclass of DetectionTrainer. Here's a brief example on how you might go about customizing your DataLoader:

# from ultralytics.models.yolo.detect import DetectionTrainer

# class CustomTrainer(DetectionTrainer):
#     def get_dataloader(self, ...):
#         # Your custom DataLoader logic here
#         ...



# from ultralytics.models.yolo.detect import DetectionTrainer


# class CustomTrainer(DetectionTrainer):
#     def get_model(self, cfg, weights):
#         """Loads a custom detection model given configuration and weight files."""
#         ...


# trainer = CustomTrainer(overrides={...})
# trainer.train()




# from ultralytics.models.yolo.detect import DetectionTrainer
# from ultralytics.nn.tasks import DetectionModel


# class MyCustomModel(DetectionModel):
#     def init_criterion(self):
#         """Initializes the loss function and adds a callback for uploading the model to Google Drive every 10 epochs."""
#         ...


# class CustomTrainer(DetectionTrainer):
#     def get_model(self, cfg, weights):
#         """Returns a customized detection model instance configured with specified config and weights."""
#         return MyCustomModel(...)


# # callback to upload model weights
# def log_model(trainer):
#     """Logs the path of the last model weight used by the trainer."""
#     last_weight_path = trainer.last
#     print(last_weight_path)


# trainer = CustomTrainer(overrides={...})
# trainer.add_callback("on_train_epoch_end", log_model)  # Adds to existing callback
# trainer.train()