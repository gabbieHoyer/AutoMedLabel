# ------------- AutoLabeling the OAI Thigh Muscle Dataset -------------- #

data:
  data_dir: standardized_data/full_thigh_nifti/train/images/OAI_9437407.nii.gz 
  # data_dir: standardized_data/challenging_cases/dicom_image_sample/00m/9015402    # dicom folder
  # data_dir: standardized_data/challenging_cases/nifti_image_sample/00m/OAI_9015402.nii.gz  # nifti file
  mask_labels:
  0: background  
  1: sc_fat
  2: fascia      
  3: extensors
  4: hamstrings
  5: fem_cortex
  6: fem_bm
  7: adductors
  8: sartorius
  9: gracilis
  10: nv

preprocessing_cfg:
  image_size: 1024 
  voxel_num_thre2d: 100
  voxel_num_thre3d: 200
  remove_label_ids: []  # No labels to remove in this configuration 
  target_label_id: null  # No specific label targeted for instance segmentation
  instance_bbox: True
  crop_non_zero_slices_flag: False
  bbox_shift: 20

device: cuda:0

models:
  obj_det: 
    model_path: 'work_dir/model_weights/finetuned/thighYOLO/best.pt'
    model_weights: 'thighYOLO8_100epoch'
    model_type: YOLO
    conf_int: 0.5
  segmentation:
    base_model: "work_dir/model_weights/SAM/sam_vit_b_01ec64.pth"
    model_path: 'work_dir/model_weights/finetuned/multiclass_Thigh_SAM/20240522-1945_finetuned_model_best.pth'
    model_weights: 'multiclass_Thigh_SAM'
    model_type: vit_b
    trainable:
      prompt_encoder: false
      image_encoder: true
      mask_decoder: true

output_configuration:
  base_output_dir: work_dir/inference
  labels_dir: annotations  # Location to output labels .txt files
  pred_dir: preds   # Location to output (gt, prediction) .npz files
  output_ext: 'nii.gz'  # [.nii.gz, .npz]
  visualize: True
  logging_level: DEBUG  # not implemented yet





    # model_path: 'work_dir/model_weights/finetuned/muscleSAM/20240530-0438_finetuned_model_best.pth'
    # model_weights: 'muscleSAM'
    # model_type: vit_b
    # trainable:
    #   prompt_encoder: false
    #   image_encoder: true
    #   mask_decoder: true


# data: standardized_data/thigh_npy3_instance/test/images/OAI_9437407-003.npy
# data: standardized_data/full_thigh_npy/test/images


# source: # (str, optional) source directory for images or videos
# vid_stride: 1 # (int) video frame-rate stride
# stream_buffer: False # (bool) buffer all streaming frames (True) or return the most recent frame (False)
# visualize: False # (bool) visualize model features
# augment: False # (bool) apply image augmentation to prediction sources
# agnostic_nms: False # (bool) class-agnostic NMS
# classes: # (int | list[int], optional) filter results by class, i.e. classes=0, or classes=[0,2,3]
# retina_masks: False # (bool) use high-resolution segmentation masks
# embed: # (list[int], optional) return feature vectors/embeddings from given layers


# see if prediction can take place on folder in images??





# resources for this development:

# https://docs.ultralytics.com/usage/engine/#other-engine-components
# https://docs.ultralytics.com/usage/engine/

# https://www.reddit.com/r/pytorch/comments/tl1a7f/yolo_annotated_dataset_to_custom_dataloader/


# Yes, it's definitely possible to define custom DataLoader and Augmentation pipelines in DetectionTrainer! ðŸš€ To do so, you'd primarily override the get_dataloader() method in a subclass of DetectionTrainer. Here's a brief example on how you might go about customizing your DataLoader:

# from ultralytics.models.yolo.detect import DetectionTrainer

# class CustomTrainer(DetectionTrainer):
#     def get_dataloader(self, ...):
#         # Your custom DataLoader logic here
#         ...



# from ultralytics.models.yolo.detect import DetectionTrainer


# class CustomTrainer(DetectionTrainer):
#     def get_model(self, cfg, weights):
#         """Loads a custom detection model given configuration and weight files."""
#         ...


# trainer = CustomTrainer(overrides={...})
# trainer.train()




# from ultralytics.models.yolo.detect import DetectionTrainer
# from ultralytics.nn.tasks import DetectionModel


# class MyCustomModel(DetectionModel):
#     def init_criterion(self):
#         """Initializes the loss function and adds a callback for uploading the model to Google Drive every 10 epochs."""
#         ...


# class CustomTrainer(DetectionTrainer):
#     def get_model(self, cfg, weights):
#         """Returns a customized detection model instance configured with specified config and weights."""
#         return MyCustomModel(...)


# # callback to upload model weights
# def log_model(trainer):
#     """Logs the path of the last model weight used by the trainer."""
#     last_weight_path = trainer.last
#     print(last_weight_path)


# trainer = CustomTrainer(overrides={...})
# trainer.add_callback("on_train_epoch_end", log_model)  # Adds to existing callback
# trainer.train()